;; The first three lines of this file were inserted by DrScheme. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-advanced-reader.ss" "lang")((modname student) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #t #t none #f ())))
;;==========================================================================
;; homework: structure representing homework points
;; nu: number - the number of the homework
;; points: number - the number of points reached
(define-struct homework (nr points))


;;==========================================================================
;; mid-term: points in one of two mid-term exams
;; nu: number - the number of the mid-term exam
;; points: number - the number of points reached
(define-struct mid-term (nr points))


;;==========================================================================
;; final-lab: points in the final-lab
;; group: number - the number of the student's group
;; points: number - the number of points reached
(define-struct final-lab (group points))


;;==========================================================================
;; student: representing a CS 1 student
;; id: number - unique ID of the student
;; name: string - the name of the student
;; hw: (listof homework) - the student's homework(s)
;; mid1: mid-term - the student's result in mid-term A
;; mid2: mid-term - the student's result in mid-term B
;; lab: final-lab - the student's results in the finallab
(define-struct student (id name hw mid1 mid2 lab))


;;==========================================================================
;; Test student
(define peter (list 
               4 ;; id
               "Peter Adam" ;; name
               (list (list 1 3) (list 2 4)) ;; listof homework
               (list 1 31) ;; mid-term 1
               (list 2 42) ;; mid-term 2
               (list 10 85))) ;; finallab

(define peter-id-wrong (list 
               'a ;; id
               "Peter Adam" ;; name
               (list (list 1 3) (list 2 4)) ;; listof homework
               (list 1 31) ;; mid-term 1
               (list 2 42) ;; mid-term 2
               (list 10 85))) ;; finallab

(define hans (make-student 3 "Hans Wurst" (list (make-homework 1 23) (make-homework 2 27) (make-homework 3 55)) (make-mid-term 1 80) (make-mid-term 2 20) (make-final-lab 10 100)))
(define dieter (make-student 4 "Dieter XYZ" (list (make-homework 1 -100) (make-homework 2 27) (make-homework 3 55)) (make-mid-term 1 80) (make-mid-term 2 20) (make-final-lab 10 100)))
(define max_m (make-student 5 "Max Mustermann" (list (make-homework 1 23) (make-homework 2 27)) (make-mid-term 1 999) (make-mid-term 2 -20) (make-final-lab 10 100)))
(define bob (make-student 6 "Bob" (list (make-homework 1 23) (make-homework 2 27) (make-homework 3 10)) (make-mid-term 1 55) (make-mid-term 2 20) (make-final-lab 10 0)))


;;==========================================================================
;; Contract: list->student: X -> student
;;        X: (list [id: number]
;;                 [name: string]
;;                 [(list-of-homework): (listof (list number number))]
;;                 [mid-term1: mid-term]
;;                 [mid-term2: mid-term]
;;                 [finallab: final-lab])
;; Purpose: turns a formated list into student-object
;; Example: (list->student 
;;      (list 4 "Peter Adam" (list (list 1 3) (list 2 4)) (list 1 31) (list 2 42) (list 10 85))))
;;      ->  (make-student 4 
;;                        ”Peter Adam” 
;;                        (list (make-homework 1 3)
;;                              (make-homework 2 4))
;;                        (make-mid-term 1 31)
;;                        (make-mid-term 2 42)
;;                        (make-final-lab 10 85))))
(define (list->student lfs) ;; lfs: list-for-student
  (cond
    [(empty? lfs) empty]
    [(not (= (length lfs) 6)) (error 'list_format_exeption "wrong number of elements in list")]
    [else 
     (local ((define id (first lfs))
             (define name (second lfs))
             (define homework (parse-homework (third lfs)))
             (define mid1 (parse-mid-term (fourth lfs)))
             (define mid2 (parse-mid-term (fifth lfs)))
             (define finallab (parse-lab (sixth lfs))))
       (cond 
         [(not (number? id)) 
          (error 'list_format_exeption "first element of list not a number")]
         
         [(not (string? name)) 
          (error 'list_format_exeption "second element of list not a string")]
         
         [(string=? name "") 
          (error 'list_format_exeption "second element of list is an empty string")]
         
         [else 
          (make-student id name homework mid1 mid2 finallab)]))]))

;;===Tests: list->student===
(check-expect (list->student peter)(make-student 4 "Peter Adam" (list (make-homework 1 3) (make-homework 2 4)) (make-mid-term 1 31) (make-mid-term 2 42) (make-final-lab 10 85)))
(check-error (list->student peter-id-wrong) "list_format_exeption: first element of list not a number")
(check-expect (list->student empty) empty)


;;==========================================================================
;; Contract: parse-homework: (listof (list number number)) -> (listof homework)
;; Purpose: parses the list of pairs of numbers to a list with homework-structs
;; Example: (parse-homework (list (list 1 2) (list 3 4)))
;;               -> (list (make-homework 1 2) (make-homework 3 4))
(define (parse-homework lopons) ;; lopons: list-of-pair-of-numbers
  (cond
    [(empty? lopons) empty]
    [else (local ((define pon (first lopons)) ;; pon: pair-of-number
                  (define rol (rest lopons))) ;; rol: rest-of-list
            
            (cond
            
              [(not (= (length pon) 2))
               (error 'homework_list_format_exeption "wrong number of elements")]
              
              [(not (andmap number? pon)) 
               (error 'homework_list_format_exeption "some elements are no numbers")]
              
              [(not (andmap positive? pon))
               (error 'homework_list_format_exeption "some numbers are negative")]
              
              [(member (first pon) (map first rol))
               (error 'homework_list_format_exeption "some homework id's are not unique")]
              
              [else 
               (cons (make-homework (first pon)(second pon)) (parse-homework rol))]))]))

;;===Tests: parse-homework===
(check-expect (parse-homework (list (list 1 2) (list 3 4)(list 5 6)))
              (list (make-homework 1 2)(make-homework 3 4)(make-homework 5 6)))
(check-error (parse-homework (list (list 1 2 3))) 
             "homework_list_format_exeption: wrong number of elements")
(check-error (parse-homework (list (list 'a 3))) 
             "homework_list_format_exeption: some elements are no numbers")
(check-error (parse-homework (list (list -1 -3))) 
             "homework_list_format_exeption: some numbers are negative")
(check-error (parse-homework (list (list 1 2)(list 1 3))) 
             "homework_list_format_exeption: some homework id's are not unique")


;;==========================================================================
;; Contract: parse-mid-term: (listof number number) -> mid-term
;; Purpose: parses the list of two numbers to a mid-term-struct
;; Example: (parse-mid-term (list 1 2)) -> (make-mid-term 1 2)
(define (parse-mid-term lonn) ;; lonn: list-of-number-number
  (cond [(and (= (length lonn) 2)
              (andmap number? lonn)
              (andmap positive? lonn)
              )
         (make-mid-term (first lonn)(second lonn))
         ]
        [else (error 'list_format_exeption "wrong formated list")]))

;;===Tests: parse-mid-term===
(check-expect(parse-mid-term (list 1 2)) (make-mid-term 1 2))
(check-error (parse-mid-term (list 1)) "list_format_exeption: wrong formated list")
(check-error (parse-mid-term (list 'a 2)) "list_format_exeption: wrong formated list")
(check-error (parse-mid-term (list 1 -2)) "list_format_exeption: wrong formated list")


;;==========================================================================
;; Contract: parse-lab: (listof number number) -> final-lab
;; Purpose: parses the list of two numbers to a final-lab-struct
;; Example: (parse-lab (list 1 2)) -> (make-final-lab 1 2)
(define (parse-lab lonn) ;; lonn: list-of-number-number
  (cond [(and (= (length lonn) 2)
              (andmap number? lonn)
              (andmap positive? lonn)
              )
         (make-final-lab (first lonn)(second lonn))
         ]
        [else (error 'list_format_exeption "wrong formated list")]))

;;===Tests: parse-lab===
(check-expect (parse-lab (list 1 2)) (make-final-lab 1 2))
(check-error (parse-lab (list 1)) "list_format_exeption: wrong formated list")
(check-error (parse-lab (list 'a 2)) "list_format_exeption: wrong formated list")
(check-error (parse-lab (list 1 -2)) "list_format_exeption: wrong formated list")


;;==========================================================================
;; Contract: passed?: student -> boolean
;; Purpose: checks if the student has passed the exam
;; Example: (passed? (list->student peter)) -> false
;; Example: (passed? hans) -> true
(define (passed? student)
  (local ((define sum-hw (sum-homework (student-hw student)))
          (define mid1-points (mid-term-points (student-mid1 student)))
          (define mid2-points (mid-term-points (student-mid2 student)))
          (define lab-points (final-lab-points (student-lab student))))
    
   (cond 
    [(and (>= sum-hw 50)
          (or (>= mid1-points 35)
              (>= mid2-points 35))
          (>= lab-points 50)
          (>= (+ sum-hw 
                 (max mid1-points mid2-points)
                 lab-points) 
              180))
          true]
    [else false])))

;;===Tests: passed?===
(check-expect (passed? (list->student peter)) false)
(check-expect (passed? hans) true)


;;==========================================================================
;; contract: valid?: student -> Boolean
;; purpose: tests wether the results of a student are valid
(define (valid? student)
  (local ((define sum-hw (sum-homework (student-hw student)))
          (define mid1-points (mid-term-points (student-mid1 student)))
          (define mid2-points (mid-term-points (student-mid2 student)))
          (define lab-points (final-lab-points (student-lab student))))
    (cond
      [(and
        (>= sum-hw 0)
        (<= sum-hw 100)
        (>= mid1-points 0)
        (<= mid1-points 100)
        (>= mid2-points 0)
        (<= mid2-points 100)
        (xor
         (= lab-points 0)
         (and
          (>= lab-points 50)
          (<= lab-points 145))))
       true]
      [else false])))

;;===Tests: valid?===
(check-expect (valid? hans) false) ;; sum of homework to high
(check-expect (valid? dieter) false) ;; negative homework-sum value
(check-expect (valid? max_m) false) ;; mid-term points to high
(check-expect (valid? bob) true) ;; should be valid


;;==========================================================================
;; contract: points-for-student: student -> number
;; purpose: calculates the reached points for a student
(define (points-for-student student)
  (local ((define sum-hw (sum-homework (student-hw student)))
          (define mid1-points (mid-term-points (student-mid1 student)))
          (define mid2-points (mid-term-points (student-mid2 student)))
          (define lab-points (final-lab-points (student-lab student)))
          (define reached-points
            (+ sum-hw
               (if (>= mid1-points mid2-points) 
                   mid1-points
                   mid2-points)
               lab-points)))
    reached-points))

;;===Tests: points-for-student===
(check-expect (points-for-student hans) 285)
(check-expect (points-for-student bob) 115)


;;==========================================================================
;; contract: students->point-list: (listof student) -> (listof number)
;; purpose: calculates the points for each student in the list
(define (students->point-list los) ;; los: list-of-students
  (cond
    [(empty? los) empty]
    [else 
     (map 
      (lambda (astudent) 
        (points-for-student astudent)) 
      los)]))
  
;;===Tests: students->point-list===
(check-expect (students->point-list (list hans dieter max_m bob)) 
              (list 285 162 1149 115))
(check-expect (students->point-list empty) empty)


;;==========================================================================
;; contract: point-dist: (listof number) -> (listof (list number number))
;; purpose: akkumulate the apperance of a number in list
;; example: (point-dist (list 3 2 1 2 3)) -> (list '(3 2) '(2 2) '(1 1))
(define (point-dist lon) ;; lon: list-of-numbers
  (local 
    ((define rl empty) ;; el: result-list
     
     ;; contract: exists: number -> Boolean
     ;; purpose: returns true if the number already exist in the nested part of the rl
     (define (exists? a-number lopon)
       (cond
         [(empty? lopon) false]
         [else 
          (ormap 
           (lambda (a-pon) (= (first a-pon) a-number)) 
           lopon)]))
     
     ;; contract: succ: number -> void
     (define (succ a-number lopon)
       (map 
        (lambda (a-pon) 
          (if (= (first a-pon) a-number)
              (list (first a-pon) (+ (second a-pon) 1))
              a-pon)) 
        lopon)))
     ;;===end of local-def block===
    
    (for-each 
     (lambda (a-number)
            (if (exists? a-number rl)
                (succ a-number)
                (append rl (list a-number 1))))
     lon)))

;;===Tests: point-dist===
;;(check-expect (point-dist (list 1 2 1 2 5 4 3)) (list (1 )))


;;==========================================================================
;; contract: xor: boolean boolean -> boolean
;; purpose: evaluates the result of an exclusive or expression
;; bitmap:   xor|1 0
;;             =====
;;             1|0 1
;;             0|1 0
(define (xor X Y) (or  ;; why the hell there is no buildin xor in plt-scheme ^^
               (and X (not Y))
               (and (not X) Y)))

;;===Tests: xor===
(check-expect (xor #t #t) #f)
(check-expect (xor #t #f) #t)
(check-expect (xor #f #t) #t)
(check-expect (xor #f #f) #f)


;;==========================================================================
;; Contract: sum-homework: (listof homework) -> number
;; Purpose: summerize the points reached in homework
;; Example: (sum-homework (list (make-homework 1 25) (make-homework 2 44))) -> 69
(define (sum-homework loh) ;; loh: list-of-homework
  (cond
    [(empty? loh) 0]
  [else (+ 
         (homework-points (first loh))
         (sum-homework (rest loh)))]))

;;===Tests: sum-homework===
(check-expect (sum-homework (list (make-homework 1 25) (make-homework 2 44))) 69)
(check-expect (sum-homework empty) 0)